
#######################################################################################################
############# variables generated by generic functions using the Use<package>-<version>.cmake #########
############# files of each dependent package - contain full path information #########################
#######################################################################################################
# for libraries components
# XXX_YYY_INCLUDE_DIRS[_DEBUG]			# all include path to use to build an executable with the library component YYY of package XXX
# XXX_YYY_DEFINITIONS[_DEBUG]			# all definitions to use to build an executable with the library component YYY of package XXX
# XXX_YYY_LIBRARIES[_DEBUG]			# all libraries path to use to build an executable with the library component YYY of package XXX

########### this part is for runtime purpose --- see later ##############
# for application components
# XXX_YYY_EXECUTABLE[_DEBUG]			# path to the executable component YYY of package XXX
# XXX_YYY_RUNTIME_LIBRARY_DIRS[_DEBUG]		# all path to folders containing all shared libraries used by the executable component YYY of package XXX 

# for "launch" components (not currently existing)
# XXX_YYY_APPS[_DEBUG]				# all executables to find for global distributed application to work defined by launch component YYY of package XXX
# XXX_YYY_APP_ZZZ_PARAMS[_DEBUG]		# all parameters used  
# XXX_YYY_APP_ZZZ_PARAM_VVV			# string parameter VVV for application ZZZ used by the launch file YYY of package XXX 
##################################################################################
##################    auxiliary functions for utility purposes ###################
##################################################################################

function(test_Package_Location DEPENDENCIES_NOTFOUND package dependency)
	if(NOT ${${dependency}_FOUND})

		if(${${package}_DEPENDENCY_${dependency}_VERSION} STREQUAL "")
			message(SEND_ERROR "The required package ${a_dependency} has not been found !")
		elseif(${${package}_DEPENDENCY_${dependency}_VERSION_EXACT})
			message(SEND_ERROR "The required package ${a_dependency} with exact version ${${package}_DEPENDENCY_${dependency}_VERSION} has not been found !")
		else()
			message(SEND_ERROR "The required package ${a_dependency} with version compatible with ${${package}_DEPENDENCY_${dependency}_VERSION} has not been found !")
		endif()
		set(${DEPENDENCIES_NOTFOUND} ${DEPENDENCIES_NOTFOUND} ${dependency} PARENT_SCOPE)
	endif()
endfunction()


###
# each dependent package version is defined as ${package}_DEPENDENCY_${dependency}_VERSION
# other variables set by the package version use file 
# ${package}_DEPENDENCY_${dependency}_REQUIRED		# TRUE if package is required FALSE otherwise (QUIET MODE)
# ${package}_DEPENDENCY_${dependency}_VERSION		# version if a version if specified
# ${package}_DEPENDENCY_${dependency}_VERSION_EXACT	# TRUE if exact version is required
# ${package}_DEPENDENCY_${dependency}_COMPONENTS	# list of components
function(resolve_Package_Dependency package dependency)
#HERE TODO Probleme de gestion de la récursion : cas de base dans lequel on "tombe" plusieurs fois sur le même package => 
# idée de base : récursion de tous les use file ? IMPOSSIBLE CAR REQUIERT DE FAIRE LE CHOIX D'UNE VERSION !!

if(${dependency}_FOUND) #the dependency has already been found (previously found in iteration or recursion, not possible to import it again)
	if(${package}_DEPENDENCY_${dependency}_VERSION) # a specific version is required
	 	if( ${package}_DEPENDENCY_${dependency}_VERSION_EXACT) #an exact version is required
			
			is_Exact_Version_Compatible_With_Previous_Constraints(IS_COMPATIBLE NEED_REFIND ${dependency} ${${package}_DEPENDENCY_${dependency}_VERSION}) # will be incompatible if a different exact version already required OR if another major version required OR if another minor version greater than the one of exact version
 
			if(IS_COMPATIBLE)
				if(NEED_REFIND)
					# OK installing the exact version instead
					#WARNING recursive call to find package
					find_package(
						${dependency} 
						${${package}_DEPENDENCY_${dependency}_VERSION} 
						EXACT
						MODULE
						REQUIRED
						${${package}_DEPENDENCY_${dependency}_COMPONENTS}
					)
				endif()
				return()				
			else() #not compatible
				message(FATAL_ERROR "impossible to find compatible versions regarding versions constraints for package ${package}")
				return()
			endif()
		else()#not an exact version required
			is_Version_Compatible_With_Previous_Constraints (
					COMPATIBLE_VERSION VERSION_TO_FIND 
					${dependency} ${${package}_DEPENDENCY_${dependency}_VERSION})
			if(COMPATIBLE_VERSION)
				if(VERSION_TO_FIND)
					find_package(
						${dependency} 
						${VERSION_TO_FIND}
						MODULE
						REQUIRED
						${${package}_DEPENDENCY_${dependency}_COMPONENTS}
					)
				else()
					return() # nothing to do more, the current used version is compatible with everything 	
				endif()
			else()
				message(FATAL_ERROR "impossible to find compatible versions regarding versions constraints for package ${package}")
				return()
			endif()
		endif()
	else()
		return()#by default the version is compatible (no constraints) so return 
	endif()
else()#the dependency has not been already found
	if(	${package}_DEPENDENCY_${dependency}_VERSION)
		
		if(${package}_DEPENDENCY_${dependency}_VERSION_EXACT) #an exact version has been specified
			#WARNING recursive call to find package
			find_package(
				${dependency} 
				${${package}_DEPENDENCY_${dependency}_VERSION} 
				EXACT
				MODULE
				REQUIRED
				${${package}_DEPENDENCY_${dependency}_COMPONENTS}
			)

		else()
			#WARNING recursive call to find package
			find_package(
				${dependency} 
				${${package}_DEPENDENCY_${dependency}_VERSION} 
				MODULE
				REQUIRED
				${${package}_DEPENDENCY_${dependency}_COMPONENTS}
			)
		endif()
	else()
		find_package(
			${dependency} 
			MODULE
			REQUIRED
			${${package}_DEPENDENCY_${dependency}_COMPONENTS}
		)
	endif()
endif()
test_Package_Location(DEPENDENCIES_NOTFOUND ${package} ${dependency})
set(${package}_DEPENDENCIES_NOTFOUND ${DEPENDENCIES_NOTFOUND} PARENT_SCOPE)
endfunction(resolve_Package_Dependency)

##################################################################################
##################    auxiliary functions fill exported variables ################
##################################################################################

###
function (update_Config_Include_Dirs package component path)
	set(${package}_${component}_INCLUDE_DIRS ${${package}_${component}_INCLUDE_DIRS} ${path} CACHE INTERNAL "")
endfunction(update_Config_Include_Dirs)

###
function (update_Config_Include_Dirs_Debug package component path)
	set(${package}_${component}_INCLUDE_DIRS_DEBUG ${${package}_${component}_INCLUDE_DIRS_DEBUG} ${path} CACHE INTERNAL "")
endfunction(update_Config_Include_Dirs_Debug)

###
function (update_Config_Definitions package component defs)
	set(${package}_${component}_DEFINITIONS ${${package}_${component}_DEFINITIONS} ${defs} CACHE INTERNAL "")
endfunction(update_Config_Definitions)


###
function(update_Config_Definitions_Debug package component defs)
	set(${package}_${component}_DEFINITIONS_DEBUG ${${package}_${component}_DEFINITIONS_DEBUG} ${defs} CACHE INTERNAL "")
endfunction(update_Config_Definitions_Debug)

###
function(update_Config_Libraries package component links)
	set(${package}_${component}_LIBRARIES ${${package}_${component}_LIBRARIES} ${links} CACHE INTERNAL "")
endfunction(update_Config_Libraries)

###
function(update_Config_Libraries_Debug package component links)
	set(${package}_${component}_LIBRARIES_DEBUG ${${package}_${component}_LIBRARIES_DEBUG} ${links} CACHE INTERNAL "")
endfunction(update_Config_Libraries_Debug)

###
function(init_Component_Variables package component path_to_version )
	set(${package}_${component}_INCLUDE_DIRS "" CACHE INTERNAL "")
	set(${package}_${component}_INCLUDE_DIRS_DEBUG "" CACHE INTERNAL "")
	set(${package}_${component}_DEFINITIONS "" CACHE INTERNAL "")
	set(${package}_${component}_DEFINITIONS_DEBUG "" CACHE INTERNAL "")
	set(${package}_${component}_LIBRARIES "" CACHE INTERNAL "")
	set(${package}_${component}_LIBRARIES_DEBUG "" CACHE INTERNAL "")
	set(${package}_${component}_EXECUTABLE "" CACHE INTERNAL "")
	set(${package}_${component}_EXECUTABLE_DEBUG "" CACHE INTERNAL "")
	is_Executable_Component(COMP_IS_EXEC ${package} ${component})
	
	if(NOT COMP_IS_EXEC)
		#exported include dirs (cflags -I<path>)
		set(${package}_${component}_INCLUDE_DIRS "${path_to_version}/include/${${package}_${component}_HEADER_DIR_NAME}" CACHE INTERNAL "")
		set(${package}_${component}_INCLUDE_DIRS_DEBUG "${path_to_version}/include/${${package}_${component}_HEADER_DIR_NAME}" CACHE INTERNAL "")
		
		#additional exported include dirs (cflags -I<path>) (external/system include dirs)
		if(${package}_${component}_INC_DIRS)
			set(	${package}_${component}_INCLUDE_DIRS 
				${${package}_${component}_INCLUDE_DIRS} 
				${${package}_${component}_INC_DIRS} 
				CACHE INTERNAL "")
		endif()
		if(${package}_${component}_INC_DIRS_DEBUG)
			set(	${package}_${component}_INCLUDE_DIRS_DEBUG 
				${${package}_${component}_INCLUDE_DIRS_DEBUG}				
				${${package}_${component}_INC_DIRS_DEBUG} 
				CACHE INTERNAL "")		
		endif()
		#exported additionnal cflags
		if(${package}_${component}_DEFS) 	
			set(${package}_${component}_DEFINITIONS ${${package}_${component}_DEFS} CACHE INTERNAL "")
		endif()
		if(${package}_${component}_DEFS_DEBUG)	
			set(${package}_${component}_DEFINITIONS_DEBUG ${${package}_${component}_DEFS_DEBUG} CACHE INTERNAL "")
		endif()

		#exported library (ldflags -l<path>)
		if(NOT ${${package}_${component}_TYPE} STREQUAL "HEADER")
			set(${package}_${component}_LIBRARIES "${path_to_version}/lib/${${package}_${component}_BINARY_NAME}" CACHE INTERNAL "")
			set(${package}_${component}_LIBRARIES_DEBUG "${path_to_version}/lib/${${package}_${component}_BINARY_NAME_DEBUG}" CACHE INTERNAL "")
		endif()

		#exported additionnal ld flags
		if(${package}_${component}_LINKS)
			set(	${package}_${component}_LIBRARIES 
				${${package}_${component}_LIBRARIES}
				${${package}_${component}_LINKS} 
				CACHE INTERNAL "")
		endif()
		if(${package}_${component}_LINKS_DEBUG)	
			set(	${package}_${component}_LIBRARIES_DEBUG 
				${${package}_${component}_LIBRARIES_DEBUG}
				${${package}_${component}_LINKS_DEBUG} 
				CACHE INTERNAL "")
		endif()
		
	elseif(${${package}_${component}_TYPE} STREQUAL "APP")
		
		set(${package}_${component}_EXECUTABLE "${path_to_version}/bin/${${package}_${component}_BINARY_NAME}" CACHE INTERNAL "")
		set(${package}_${component}_EXECUTABLE_DEBUG "${path_to_version}/bin/${${package}_${component}_BINARY_NAME_DEBUG}" CACHE INTERNAL "")
	endif()
endfunction(init_Component_Variables)

### 
functions(update_Component_Build_Variables_With_Dependency package component dep_package dep_component)

if(${${package}_${component}_EXPORT_${dep_package}_${dep_component}})
	update_Config_Include_Dirs(${package} ${component} ${${dep_package}_${dep_component}_INCLUDE_DIRS})
	update_Config_Include_Dirs_Debug(${package} ${component} ${${dep_package}_${dep_component}_INCLUDE_DIRS_DEBUG})
	update_Config_Definitions(${package} ${component} ${${dep_package}_${dep_component}_DEFINITIONS})
	update_Config_Definitions_Debug(${package} ${component} ${${dep_package}_${dep_component}_DEFINITIONS_DEBUG})
endif()

# libraries are always exported to enable the linking	
update_Config_Libraries(${package} ${component} ${${dep_package}_${dep_component}_LIBRARIES})
update_Config_Libraries_Debug(${package} ${component} ${${dep_package}_${dep_component}_LIBRARIES_DEBUG})
endfunction()

#TODO managing the automatic installation of binay packages or git repo (if not exist) !!

##################################################################################
##################################  main macro  ##################################
##################################################################################
#TODO gérer le mode debug ou release de manière différente !!!!!!!!! prendre en compte les champs _DEBUG sur les dependencies
function(configure_Package_Build_Variables package_name path_to_version)
# 1) managing package dependencies (the list of dependent packages is defined as ${package_name}_DEPENDENCIES)
# - locating dependent packages in the workspace and configuring their build variables recursively 
foreach(a_dependency IN ITEMS ${${package_name}_DEPENDENCIES}) 
	resolve_Package_Dependency(${package_name} ${a_dependency})
endforeach()

if(${package}_DEPENDENCIES_NOTFOUND)
	message(FATAL_ERROR "Some dependencies have not been found exitting")
	#TODO here managing the automatic installation of binay packages or git repo (if not exist)
endif()


# 2) initializing all build variable that are internal to each component of the current package
foreach(a_component IN ITEMS ${${package_name}_COMPONENTS})
	init_Component_Variables ${package_name} ${a_component} ${path_to_version})
endforeach()


# 3) setting build variables with informations coming from package dependancies
foreach(a_component IN ITEMS ${${package_name}_COMPONENTS}) 
	foreach(a_package IN ITEMS ${${package_name}_${a_component}_DEPENDENCIES}) 
		foreach(a_dep_component IN ITEMS ${${package_name}_${a_component}_DEPENDENCY_${a_package}_COMPONENTS}) 
			update_Component_Build_Variables_With_Dependency (${package_name} ${a_component} ${a_package} ${a_dep_component})
		endforeach()
	endforeach()		
endforeach()

#4) setting build variables with informations coming from INTERNAL package dependancies
# these have not been checked like the others since the package components discovering mecanism has already done the job 
foreach(a_component IN ITEMS ${${package_name}_COMPONENTS}) 
	foreach(a_dep_component IN ITEMS ${${package_name}_${a_component}_INTERNAL_DEPENDENCIES}) 
		update_Component_Build_Variables_With_Dependency (${package_name} ${a_component} ${package_name} ${a_dep_component})
	endforeach()
endforeach()

# no need to check system/external dependencies as they are already  treaten as special cases (see variable <package>__<component>_LINKS and <package>__<component>_DEFS of components)
# quite like in pkg-config tool
endfunction(configure_Package_Build_Variables)

