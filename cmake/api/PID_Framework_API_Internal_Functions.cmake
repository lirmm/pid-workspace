#########################################################################################
#       This file is part of the program PID                                            #
#       Program description : build system supportting the PID methodology              #
#       Copyright (C) Robin Passama, LIRMM (Laboratoire d'Informatique de Robotique     #
#       et de Microelectronique de Montpellier). All Right reserved.                    #
#                                                                                       #
#       This software is free software: you can redistribute it and/or modify           #
#       it under the terms of the CeCILL-C license as published by                      #
#       the CEA CNRS INRIA, either version 1                                            #
#       of the License, or (at your option) any later version.                          #
#       This software is distributed in the hope that it will be useful,                #
#       but WITHOUT ANY WARRANTY; without even the implied warranty of                  #
#       MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the                    #
#       CeCILL-C License for more details.                                              #
#                                                                                       #
#       You can find the complete license description on the official website           #
#       of the CeCILL licenses family (http://www.cecill.info/index.en.html)            #
#########################################################################################


########################################################################
############ inclusion of required macros and functions ################
########################################################################
include(PID_Set_Modules_Path NO_POLICY_SCOPE)
include(PID_Set_Policies NO_POLICY_SCOPE)
include(PID_Package_Cache_Management_Functions NO_POLICY_SCOPE)
include(PID_Deployment_Functions NO_POLICY_SCOPE)
include(PID_Utils_Functions NO_POLICY_SCOPE)
include(PID_Version_Management_Functions NO_POLICY_SCOPE)
include(PID_Continuous_Integration_Functions NO_POLICY_SCOPE)
include(PID_Git_Functions NO_POLICY_SCOPE)
include(PID_Meta_Information_Management_Functions NO_POLICY_SCOPE)
include(PID_Contribution_Space_Functions NO_POLICY_SCOPE)
include(PID_Platform_Management_Functions NO_POLICY_SCOPE)

##################################################################################
##################  declaration of a lone package static site ####################
##################################################################################

#.rst:
#
# .. ifmode:: internal
#
#  .. |declare_PID_Site| replace:: ``declare_PID_Site``
#  .. _declare_PID_Site:
#
#  declare_PID_Site
#  ----------------
#
#   .. command:: declare_PID_Site()
#
#    Declare that the current CMake project is a lone static site generated by a package or wrapper.
#
#     :PACKAGE_URL <url>: The online url where to find the package or wrapper project page.
#     :SITE_URL <url>: The online url of the package or wrapper's lone static site.
#
macro(declare_PID_Site)
set(oneValueArgs PACKAGE_URL SITE_URL)
cmake_parse_arguments(DECLARE_PID_SITE "" "${oneValueArgs}" "" ${ARGN} )
declare_Site("${DECLARE_PID_SITE_PACKAGE_URL}" "${DECLARE_PID_SITE_SITE_URL}")
endmacro(declare_PID_Site)

############ function used to create the README.md file of the site  ###########

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Site_Readme_File| replace:: ``generate_Site_Readme_File``
#  .. _generate_Site_Readme_File:
#
#  generate_Site_Readme_File
#  -------------------------
#
#   .. command:: generate_Site_Readme_File()
#
#    Generate a readme file for the lone static site project.
#
function(generate_Site_Readme_File)
set(README_CONFIG_FILE ${WORKSPACE_DIR}/cmake/patterns/static_sites/README.md.in)
set(PACKAGE_NAME ${PROJECT_NAME})
set(PACKAGE_PROJECT_REPOSITORY ${${PROJECT_NAME}_PROJECT_PAGE})
configure_file(${README_CONFIG_FILE} ${CMAKE_SOURCE_DIR}/README.md @ONLY)#put it in the source dir
endfunction(generate_Site_Readme_File)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Site_Data| replace:: ``generate_Site_Data``
#  .. _generate_Site_Data:
#
#  generate_Site_Data
#  ------------------
#
#   .. command:: generate_Site_Data()
#
#    Generate basic files and directory structure for jekyll for the current lone static site project.
#
function(generate_Site_Data)
# 1) generate the basic site structure and default files from a pattern
if(EXISTS ${CMAKE_BINARY_DIR}/to_generate)
	file(REMOVE_RECURSE ${CMAKE_BINARY_DIR}/to_generate)
endif()
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/to_generate)

execute_process(COMMAND ${CMAKE_COMMAND} -E copy_directory ${WORKSPACE_DIR}/cmake/patterns/static_sites/static ${CMAKE_BINARY_DIR}/to_generate
								WORKING_DIRECTORY ${CMAKE_BINARY_DIR})

#2) generating the global configuration file for package site
if(${PROJECT_NAME}_SITE_PAGE)
	get_Jekyll_URLs(${${PROJECT_NAME}_SITE_PAGE} PUBLIC_URL BASE_URL)
	set(PACKAGE_SITE_URL ${PUBLIC_URL})
	if(BASE_URL AND NOT BASE_URL STREQUAL "")
		set(PACKAGE_SITE_BASE_FOLDER "/${BASE_URL}")
	else()
		set(PACKAGE_SITE_BASE_FOLDER)
	endif()
else()
	set(PACKAGE_SITE_URL)
	set(PACKAGE_SITE_BASE_FOLDER)
endif()

configure_file(${WORKSPACE_DIR}/cmake/patterns/static_sites/_config.yml.in ${CMAKE_BINARY_DIR}/to_generate/_config.yml @ONLY)
endfunction(generate_Site_Data)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Site_Binary_References| replace:: ``generate_Site_Binary_References``
#  .. _generate_Site_Binary_References:
#
#  generate_Site_Binary_References
#  -------------------------------
#
#   .. command:: generate_Site_Binary_References()
#
#    Generate the cmake script referencing known binary archives for the current lone static site project.
#
function(generate_Site_Binary_References)
set(dir ${CMAKE_SOURCE_DIR}/src/_binaries)
set(file ${dir}/binary_references.cmake)
file(WRITE ${file} "# Contains references to binaries that are available for ${PROJECT_NAME} \n")
#this may overwrite binary references hard coded in the reference file, or simply add new ones

##################################################################
### all available versions of the package for which there is a ###
### reference to a downloadable binary for any platform ##########
##################################################################
list_Subdirectories(ALL_VERSIONS ${dir})
set(${PROJECT_NAME}_REFERENCES)
foreach(ref_version IN LISTS ALL_VERSIONS) #for each available version, all os for which there is a reference
	set(VERSION_REGISTERED FALSE)

	list_Subdirectories(ALL_PLATFORMS ${dir}/${ref_version})
	foreach(ref_platform IN LISTS ALL_PLATFORMS)#for each platform of this version

		extract_Info_From_Platform(RES_ARCH RES_BITS RES_OS RES_ABI RES_INSTANCE RES_PLATFORM_BASE ${ref_platform})

		# now referencing the binaries
		list_Regular_Files(ALL_BINARIES ${dir}/${ref_version}/${ref_platform})
		if(	ALL_BINARIES
			AND EXISTS ${dir}/${ref_version}/${ref_platform}/${PROJECT_NAME}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz)#release version must exist in any case

			if(NOT VERSION_REGISTERED)  # the version is registered only if there are binaries inside (sanity check)
				list(APPEND ${PROJECT_NAME}_REFERENCES ${ref_version})
				set(${PROJECT_NAME}_REFERENCE_${ref_version})
				set(VERSION_REGISTERED TRUE)
			endif()
			list(APPEND ${PROJECT_NAME}_REFERENCE_${ref_version} ${ref_platform})
			set(${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL ${${PROJECT_NAME}_SITE_PAGE}/binaries/${ref_version}/${ref_platform}/${PROJECT_NAME}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz)
			if(EXISTS ${dir}/${ref_version}/${ref_platform}/${PROJECT_NAME}-${RES_PLATFORM_BASE}-dbg-${ref_platform}.tar.gz)# binary versions for debug may exist
				set(${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG ${${PROJECT_NAME}_SITE_PAGE}/binaries/${ref_version}/${ref_platform}/${PROJECT_NAME}-${ref_version}-dbg-${RES_PLATFORM_BASE}.tar.gz)
			endif()
		endif()
	endforeach()
endforeach()
if(${PROJECT_NAME}_REFERENCES)#there are registered references
	file(APPEND ${file} "set(${PROJECT_NAME}_REFERENCES ${${PROJECT_NAME}_REFERENCES} CACHE INTERNAL \"\")\n") # the version is registered
	foreach(ref_version IN LISTS ${PROJECT_NAME}_REFERENCES)
		list(REMOVE_DUPLICATES ${PROJECT_NAME}_REFERENCES${ref_version}) #there is at least one platform referenced so no need to test for nullity
		file(APPEND ${file} "set(${PROJECT_NAME}_REFERENCE_${ref_version} ${${PROJECT_NAME}_REFERENCE_${ref_version}} CACHE INTERNAL \"\")\n")

		foreach(ref_platform IN LISTS ${PROJECT_NAME}_REFERENCE_${ref_version})
			#release binary referencing
			file(APPEND ${file} "set(${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL ${${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL} CACHE INTERNAL \"\")\n")#reference on the release binary
					#debug binary referencing
			if(${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG) #always true for open source native packages, may be true for external packages, never true for close source native packages
				file(APPEND ${file} "set(${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG ${${PROJECT_NAME}_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG} CACHE INTERNAL \"\")\n")#reference on the debug binary
			endif()
		endforeach()
	endforeach()
endif()
endfunction(generate_Site_Binary_References)

#.rst:
#
# .. ifmode:: internal
#
#  .. |declare_Site| replace:: ``declare_Site``
#  .. _declare_Site:
#
#  declare_Site
#  ------------
#
#   .. command:: declare_Site()
#
#   Define current project as a lone package or wrapper static site. Internal counterpart to declare_PID_Site.
#
function(declare_Site package_url site_url)
set(${PROJECT_NAME}_PROJECT_PAGE ${package_url} CACHE INTERNAL "")
set(${PROJECT_NAME}_SITE_PAGE ${site_url} CACHE INTERNAL "")
file(RELATIVE_PATH DIR_NAME ${CMAKE_SOURCE_DIR} ${CMAKE_BINARY_DIR})
if(DIR_NAME STREQUAL "build")

	generate_Site_Readme_File() # generating the simple README file for the project
	generate_Site_Data() #generating the jekyll source folder in build tree
	generate_Site_Binary_References() #generating the cmake script that references available binaries

	#searching for jekyll (static site generator)
	if(JEKYLL_EXECUTABLE)
		get_Jekyll_URLs(${${PROJECT_NAME}_PROJECT_PAGE} PUBLIC_URL BASE_URL)
		set(STATIC_SITE_BASEURL "${BASE_URL}")
		add_custom_target(build
			COMMAND ${CMAKE_COMMAND}	-DWORKSPACE_DIR=${WORKSPACE_DIR}
							-DTARGET_PACKAGE=${PROJECT_NAME}
							-DJEKYLL_EXECUTABLE=${JEKYLL_EXECUTABLE}
							-P ${WORKSPACE_DIR}/cmake/commands/Build_PID_Package_Site.cmake
			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
			COMMENT "[PID] Building package site ..."
			VERBATIM
		)

		add_custom_target(serve
			COMMAND ${CMAKE_COMMAND}	-DWORKSPACE_DIR=${WORKSPACE_DIR}
							-DTARGET_PACKAGE=${PROJECT_NAME}
							-DJEKYLL_EXECUTABLE=${JEKYLL_EXECUTABLE}
							-DSITE_BASE_URL=${STATIC_SITE_BASEURL}
							-P ${WORKSPACE_DIR}/cmake/commands/Serve_PID_Package_Site.cmake
			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
			COMMENT "[PID] Serving the static site of the package ..."
			VERBATIM
		)

	  add_custom_target(hard_clean
	  COMMAND ${CMAKE_COMMAND}
	            -DWORKSPACE_DIR=${WORKSPACE_DIR}
	            -DTARGET_FRAMEWORK=${PROJECT_NAME}
	  					-DADDITIONAL_DEBUG_INFO=${ADDITIONAL_DEBUG_INFO}
	  					-P ${WORKSPACE_DIR}/cmake/commands/Hard_Clean_PID_Package.cmake
	  	WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
	  )

	else()
		message("[PID] ERROR: the jekyll executable cannot be found in the system, please install it and put it in a standard path.")
	endif()
else()
	message("[PID] ERROR : please run cmake in the build folder of the package ${PROJECT_NAME} static site.")
	return()
endif()
endfunction(declare_Site)

##################################################################################
##########################  declaration of a framework ###########################
##################################################################################

#.rst:
#
# .. ifmode:: internal
#
#  .. |declare_Framework| replace:: ``declare_Framework``
#  .. _declare_Framework:
#
#  declare_Framework
#  -----------------
#
#   .. command:: declare_Framework(author institution mail year site license git_address repo_site description)
#
#   Define current project as a PID framework. Internal counterpart to declare_PID_Framework.
#
#      :author: the name of framework contact author.
#      :institution: the name of the institution of the contact author
#      :mail: the mail of contact author
#      :year: the dates of project lifecyle.
#      :site: the url of the static site generated by the framework.
#      :license: the name of the license applying to the framework's content.
#      :git_address: the url of the framework repository for push and pull actions.
#      :public_address: the url of the framework repository for public pull actions.
#      :repo_site: the online url of framework project page.
#      :description: description of the framework.
#      :welcome: path relative to src/pages folder, that targets a welcome page in markdown or html format.
#      :contrib_space: name of the default contribution space for the package.
#
macro(declare_Framework author institution mail year site license git_address public_address repo_site description welcome contrib_space)
manage_Current_Platform("${CMAKE_BINARY_DIR}" "FRAMEWORK") #loading the current platform configuration and perform adequate actions if any changes

configure_Git()
if(NOT GIT_CONFIGURED)
	message(FATAL_ERROR "[PID] CRITICAL ERROR: your git tool is NOT configured. To use PID you need to configure git:\ngit config --global user.name \"Your Name\"\ngit config --global user.email <your email address>\n")
	return()
endif()
update_Git_Ignore_File(${WORKSPACE_DIR}/cmake/patterns/frameworks/framework/.gitignore)

if(CMAKE_BINARY_DIR MATCHES "${PROJECT_NAME}/build$")
	set(${PROJECT_NAME}_ROOT_DIR CACHE INTERNAL "")
	set(CMAKE_MODULE_PATH ${CMAKE_SOURCE_DIR}/share/cmake ${CMAKE_MODULE_PATH}) # adding the cmake scripts files from the framework

	init_PID_Version_Variable(${PROJECT_NAME} ${CMAKE_SOURCE_DIR}) # getting the workspace version used to generate the code
	init_Meta_Info_Cache_Variables("${author}" "${institution}" "${mail}" "${description}" "${year}" "${license}" "${git_address}" "${public_address}" "" "${site}" "${repo_site}" "${welcome}")
	set_Cache_Entry_For_Default_Contribution_Space("${contrib_space}")
	declare_Framework_Global_Cache_Options()
	check_For_Remote_Respositories("${ADDITIONAL_DEBUG_INFO}")#configuring git remotes

	#searching for jekyll (static site generator)
	if(JEKYLL_EXECUTABLE)
		get_Jekyll_URLs(${${PROJECT_NAME}_SITE} PUBLIC_URL BASE_URL)
		set(STATIC_SITE_BASEURL "${BASE_URL}")

		add_custom_target(build
			COMMAND ${CMAKE_COMMAND}	-DFRAMEWORK_PATH=${CMAKE_SOURCE_DIR}
							-DTARGET_FRAMEWORK=${PROJECT_NAME}
							-DJEKYLL_EXECUTABLE=${JEKYLL_EXECUTABLE}
							-DINCREMENTAL_BUILD=\${incremental}
							-P ${WORKSPACE_DIR}/cmake/commands/Build_PID_Framework.cmake
			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
			COMMENT "[PID] Building framework ${PROJECT_NAME} ..."
			VERBATIM
		)

		add_custom_target(serve
			COMMAND ${CMAKE_COMMAND}	-DFRAMEWORK_PATH=${CMAKE_SOURCE_DIR}
							-DTARGET_FRAMEWORK=${PROJECT_NAME}
							-DJEKYLL_EXECUTABLE=${JEKYLL_EXECUTABLE}
							-DFRAMEWORK_BASE_URL=${STATIC_SITE_BASEURL}
							-P ${WORKSPACE_DIR}/cmake/commands/Serve_PID_Framework.cmake
			WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
			COMMENT "[PID] Serving the static site of the framework ${PROJECT_NAME} ..."
			VERBATIM
		)

	  # update target (update the framework from upstream git repository)
	  add_custom_target(update
	    COMMAND ${CMAKE_COMMAND}
	            -DWORKSPACE_DIR=${WORKSPACE_DIR}
	            -DTARGET_FRAMEWORK=${PROJECT_NAME}
	            -P ${WORKSPACE_DIR}/cmake/commands/Update_PID_Deployment_Unit.cmake
	    COMMENT "[PID] Updating the framework ${PROJECT_NAME} ..."
	    VERBATIM
	  )
	else()
		message("[PID] ERROR: the jekyll executable cannot be found in the system, please install it and put it in a standard path.")
	endif()
else()
	message("[PID] ERROR : please run cmake in the build folder of the framework ${PROJECT_NAME}.")
	return()
endif()
endmacro(declare_Framework)


#.rst:
#
# .. ifmode:: internal
#
#  .. |declare_Framework_Global_Cache_Options| replace:: ``declare_Framework_Global_Cache_Options``
#  .. _declare_Framework_Global_Cache_Options:
#
#  declare_Framework_Global_Cache_Options
#  --------------------------------------
#
#   .. command:: declare_Framework_Global_Cache_Options()
#
#     Declare configurable options for the currently built framework.
#
macro(declare_Framework_Global_Cache_Options)
option(ADDITIONAL_DEBUG_INFO "Getting more info on debug mode or more PID messages (hidden by default)" OFF)
endmacro(declare_Framework_Global_Cache_Options)


#.rst:
#
# .. ifmode:: internal
#
#  .. |declare_Framework_Image| replace:: ``declare_Framework_Image``
#  .. _declare_Framework_Image:
#
#  declare_Framework_Image
#  -----------------------
#
#   .. command:: declare_Framework_Image(image_file_path is_banner)
#
#   Define an image to use in static site generated by the current framework project.
#
#      :image_file_path: the path to the image file, relative to the src/assets folder of the framework.
#      :is_banner: if TRUE the image is used as a banner, otherwise it is used as a logo
#
macro(declare_Framework_Image image_file_path is_banner)
set(IMG_TYPE ${is_banner})
if(IMG_TYPE)
	set(${PROJECT_NAME}_FRAMEWORK_BANNER_IMAGE_FILE_NAME ${image_file_path})
else() #this is a logo
	set(${PROJECT_NAME}_FRAMEWORK_LOGO_IMAGE_FILE_NAME ${image_file_path})
endif()
endmacro(declare_Framework_Image)

#.rst:
#
# .. ifmode:: internal
#
#  .. |add_Framework_Author| replace:: ``add_Framework_Author``
#  .. _add_Framework_Author:
#
#  add_Framework_Author
#  --------------------
#
#   .. command:: add_Framework_Author(author institution)
#
#   Add an author to the current framework project.
#
#      :author: the author name
#      :institution: the author institution.
#
function(add_Framework_Author author institution)
	set(res_string_author)
	foreach(string_el IN LISTS author)
		set(res_string_author "${res_string_author}_${string_el}")
	endforeach()
	set(res_string_instit)
	foreach(string_el IN LISTS institution)
		set(res_string_instit "${res_string_instit}_${string_el}")
	endforeach()
	if(res_string_instit)
		set(${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS "${${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS};${res_string_author}(${res_string_instit})" CACHE INTERNAL "")
	else()
		set(${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS "${${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS};${res_string_author}" CACHE INTERNAL "")
	endif()
endfunction(add_Framework_Author)

#.rst:
#
# .. ifmode:: internal
#
#  .. |add_Framework_Category| replace:: ``add_Framework_Category``
#  .. _add_Framework_Category:
#
#  add_Framework_Category
#  ----------------------
#
#   .. command:: add_Framework_Category(category)
#
#   Add a category to the current framework project. This category will be used to classify native/external packages within generated static site.
#
#      :category: the string describing the category.
#
function(add_Framework_Category category)
	set(${PROJECT_NAME}_CATEGORIES ${${PROJECT_NAME}_CATEGORIES} ${category} CACHE INTERNAL "")
endfunction(add_Framework_Category)

##################################################################################
############################### building the framework ###########################
##################################################################################

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_Readme_File| replace:: ``generate_Framework_Readme_File``
#  .. _generate_Framework_Readme_File:
#
#  generate_Framework_Readme_File
#  ------------------------------
#
#   .. command:: generate_Framework_Readme_File()
#
#   Create the readme file within the current framework project.
#
function(generate_Framework_Readme_File)
set(README_CONFIG_FILE ${WORKSPACE_DIR}/cmake/patterns/frameworks/README.md.in)

set(FRAMEWORK_NAME ${PROJECT_NAME})
set(FRAMEWORK_SITE ${${PROJECT_NAME}_SITE})
set(README_OVERVIEW "${${PROJECT_NAME}_DESCRIPTION}") #if no detailed description provided by wiki description use the short one

if(${PROJECT_NAME}_LICENSE)
	set(LICENSE_FOR_README "The license that applies to this repository project is **${${PROJECT_NAME}_LICENSE}**.")
else()
	set(LICENSE_FOR_README "The framework has no license defined yet.")
endif()

set(README_AUTHORS_LIST "")
foreach(author IN LISTS ${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS)
	generate_Full_Author_String(${author} STRING_TO_APPEND)
	set(README_AUTHORS_LIST "${README_AUTHORS_LIST}\n+ ${STRING_TO_APPEND}")
endforeach()

get_Formatted_Framework_Contact_String(${PROJECT_NAME} RES_STRING)
set(README_CONTACT_AUTHOR "${RES_STRING}")

configure_file(${README_CONFIG_FILE} ${CMAKE_SOURCE_DIR}/README.md @ONLY)#put it in the source dir
endfunction(generate_Framework_Readme_File)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_License_File| replace:: ``generate_Framework_License_File``
#  .. _generate_Framework_License_File:
#
#  generate_Framework_License_File
#  -------------------------------
#
#   .. command:: generate_Framework_License_File()
#
#   Create the license file within the current framework project.
#
function(generate_Framework_License_File)
if(	${PROJECT_NAME}_LICENSE)
	resolve_License_File(PATH_TO_FILE ${${PROJECT_NAME}_LICENSE})
	if(NOT PATH_TO_FILE)
		message("[PID] WARNING : license configuration file for ${${PROJECT_NAME}_LICENSE} not found in any contribution space installed in workspace, license file will not be generated.")
	else()
		#prepare license generation
		set(${PROJECT_NAME}_FOR_LICENSE "${PROJECT_NAME} framework")
		set(${PROJECT_NAME}_DESCRIPTION_FOR_LICENSE ${${PROJECT_NAME}_DESCRIPTION})
		set(${PROJECT_NAME}_YEARS_FOR_LICENSE ${${PROJECT_NAME}_YEARS})
		foreach(author IN LISTS ${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS)
			generate_Full_Author_String(${author} STRING_TO_APPEND)
			set(${PROJECT_NAME}_AUTHORS_LIST_FOR_LICENSE "${${PROJECT_NAME}_AUTHORS_LIST_FOR_LICENSE} ${STRING_TO_APPEND}")
		endforeach()
		include(${PATH_TO_FILE})
		file(WRITE ${CMAKE_SOURCE_DIR}/license.txt ${LICENSE_LEGAL_TERMS})
	endif()
endif()
endfunction(generate_Framework_License_File)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_Data| replace:: ``generate_Framework_Data``
#  .. _generate_Framework_Data:
#
#  generate_Framework_Data
#  -----------------------
#
#   .. command:: generate_Framework_Data()
#
#   Generate data files for jekyll within the current framework project.
#
function(generate_Framework_Data)
# 1) generate the basic site structure and default files from a pattern
if(EXISTS ${CMAKE_BINARY_DIR}/to_generate)
	file(REMOVE_RECURSE ${CMAKE_BINARY_DIR}/to_generate)
endif()
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/to_generate)

execute_process(COMMAND ${CMAKE_COMMAND} -E copy_directory ${WORKSPACE_DIR}/cmake/patterns/frameworks/static ${CMAKE_BINARY_DIR}/to_generate)
file(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/to_generate/_data)

# 2) generate the data file containing general information about the framework (generated from a CMake pattern file)
set(FRAMEWORK_NAME ${PROJECT_NAME})
if(${PROJECT_NAME}_SITE)
	get_Jekyll_URLs(${${PROJECT_NAME}_SITE} PUBLIC_URL BASE_URL)
	set(FRAMEWORK_SITE_URL ${PUBLIC_URL})
	if(BASE_URL)
		set(FRAMEWORK_SITE_BASE_FOLDER "/${BASE_URL}")
	else()
		set(FRAMEWORK_SITE_BASE_FOLDER)
	endif()
else()
	set(FRAMEWORK_SITE_URL)
	set(FRAMEWORK_SITE_BASE_FOLDER)
endif()

set(FRAMEWORK_PROJECT_REPOSITORY_PAGE ${${PROJECT_NAME}_PROJECT_PAGE})
get_Formatted_Framework_Contact_String(${PROJECT_NAME} RES_STRING)
set(FRAMEWORK_MAINTAINER_NAME ${RES_STRING})
set(FRAMEWORK_MAINTAINER_MAIL ${${PROJECT_NAME}_CONTACT_MAIL})
set(FRAMEWORK_AUTHORS "<ul>")
foreach(author IN LISTS ${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS)
	get_Formatted_Author_String(${author} RES_STRING)
	set(FRAMEWORK_AUTHORS "${FRAMEWORK_AUTHORS}\n<li> ${RES_STRING}")
endforeach()
set(FRAMEWORK_AUTHORS "${FRAMEWORK_AUTHORS}\n</ul>")

set(FRAMEWORK_DESCRIPTION ${${PROJECT_NAME}_DESCRIPTION})
set(FRAMEWORK_BANNER ${${PROJECT_NAME}_FRAMEWORK_BANNER_IMAGE_FILE_NAME})
set(FRAMEWORK_LOGO ${${PROJECT_NAME}_FRAMEWORK_LOGO_IMAGE_FILE_NAME})
if(${PROJECT_NAME}_WELCOME)
	get_filename_component(WELCOME_ONLY_NAME ${${PROJECT_NAME}_WELCOME} NAME_WE)
	get_filename_component(WELCOME_ONLY_DIR ${${PROJECT_NAME}_WELCOME} DIRECTORY)
	if(WELCOME_ONLY_DIR)
		set(WELCOME_WITHOUT_EXT ${WELCOME_ONLY_DIR}/${WELCOME_ONLY_NAME})
	else()
		set(WELCOME_WITHOUT_EXT ${WELCOME_ONLY_NAME})
	endif()
	set(FRAMEWORK_WELCOME ${WELCOME_WITHOUT_EXT}.html)
else()
	set(FRAMEWORK_WELCOME)
endif()
configure_file(${WORKSPACE_DIR}/cmake/patterns/frameworks/framework.yml.in ${CMAKE_BINARY_DIR}/to_generate/_data/framework.yml @ONLY)

# 3) generate the data file defining categories managed by the framework (generated from scratch)
file(WRITE ${CMAKE_BINARY_DIR}/to_generate/_data/categories.yml "")
foreach(cat IN LISTS ${PROJECT_NAME}_CATEGORIES)
	extract_All_Words_From_Path(${cat} "_" LIST_OF_NAMES)
	list(LENGTH LIST_OF_NAMES SIZE)
	set(FINAL_NAME "")
	if(SIZE GREATER 1)# there are subcategories
		foreach(name IN LISTS LIST_OF_NAMES)
			extract_All_Words(${name} "_" NEW_NAMES)# replace underscores with spaces

			fill_String_From_List(RES_STRING NEW_NAMES " ")
			set(FINAL_NAME "${FINAL_NAME} ${RES_STRING}")
			math(EXPR SIZE "${SIZE}-1")
			if(SIZE GREATER 0) #there is more than on categrization level remaining
				set(FINAL_NAME "${FINAL_NAME}/ ")
			endif()

		endforeach()
		file(APPEND ${CMAKE_BINARY_DIR}/to_generate/_data/categories.yml "- name: \"${FINAL_NAME}\"\n  index: \"${cat}\"\n\n")
	else()
		extract_All_Words(${cat} "_" NEW_NAMES)# replace underscores with spaces
		fill_String_From_List(RES_STRING NEW_NAMES " ")
		set(FINAL_NAME "${RES_STRING}")
		file(APPEND ${CMAKE_BINARY_DIR}/to_generate/_data/categories.yml "- name: \"${FINAL_NAME}\"\n  index: \"${cat}\"\n\n")
	endif()
endforeach()

# 4) generate the configuration file for jekyll generation
configure_file(${WORKSPACE_DIR}/cmake/patterns/frameworks/_config.yml.in ${CMAKE_BINARY_DIR}/to_generate/_config.yml @ONLY)
endfunction(generate_Framework_Data)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_Reference_File| replace:: ``generate_Framework_Reference_File``
#  .. _generate_Framework_Reference_File:
#
#  generate_Framework_Reference_File
#  ---------------------------------
#
#   .. command:: generate_Framework_Reference_File(pathtonewfile)
#
#   Create a reference file for the current framework project.
#
#     :pathtonewfile: the path to the file to create.
#
function(generate_Framework_Reference_File pathtonewfile)
set(file ${pathtonewfile})
file(WRITE ${file} "")

file(APPEND ${file} "#### referencing framework ${PROJECT_NAME} mode ####\n")
file(APPEND ${file} "set(${PROJECT_NAME}_MAIN_AUTHOR ${${PROJECT_NAME}_MAIN_AUTHOR} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_MAIN_INSTITUTION ${${PROJECT_NAME}_MAIN_INSTITUTION} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_YEARS ${${PROJECT_NAME}_YEARS} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_CONTACT_MAIL ${${PROJECT_NAME}_CONTACT_MAIL} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_SITE ${${PROJECT_NAME}_SITE} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_PROJECT_PAGE ${${PROJECT_NAME}_PROJECT_PAGE} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_DESCRIPTION ${${PROJECT_NAME}_DESCRIPTION} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_LICENSE ${${PROJECT_NAME}_LICENSE} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_ADDRESS ${${PROJECT_NAME}_ADDRESS} CACHE INTERNAL \"\")\n")
file(APPEND ${file} "set(${PROJECT_NAME}_PUBLIC_ADDRESS ${${PROJECT_NAME}_PUBLIC_ADDRESS} CACHE INTERNAL \"\")\n")

# writing concise author information
set(res_string "")
foreach(auth IN LISTS ${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS)
	list(APPEND res_string ${auth})
endforeach()
set(printed_authors "${res_string}")
file(APPEND ${file} "set(${PROJECT_NAME}_AUTHORS_AND_INSTITUTIONS \"${res_string}\" CACHE INTERNAL \"\")\n")

# writing concise category information
if(${PROJECT_NAME}_CATEGORIES)
	file(APPEND ${file} "set(${PROJECT_NAME}_CATEGORIES \"${${PROJECT_NAME}_CATEGORIES}\" CACHE INTERNAL \"\")\n")
else()
	file(APPEND ${file} "set(${PROJECT_NAME}_CATEGORIES CACHE INTERNAL \"\")\n")
endif()
endfunction(generate_Framework_Reference_File)


#.rst:
#
# .. ifmode:: internal
#
#  .. |update_Environment_CI_Config_File| replace:: ``update_Environment_CI_Config_File``
#  .. _update_Environment_CI_Config_File:
#
#  update_Environment_CI_Config_File
#  ----------------------------------
#
#   .. command:: update_Environment_CI_Config_File(pathtonewfile)
#
#   Update the CI config file with the one coming from the workspace
#
function(update_Environment_CI_Config_File)
file(COPY ${WORKSPACE_DIR}/cmake/patterns/frameworks/framework/.gitlab-ci.yml DESTINATION ${CMAKE_SOURCE_DIR})
verify_Framework_CI_Content()
endfunction(update_Environment_CI_Config_File)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_Binary_References| replace:: ``generate_Framework_Binary_References``
#  .. _generate_Framework_Binary_References:
#
#  generate_Framework_Binary_References
#  ------------------------------------
#
#   .. command:: generate_Framework_Binary_References(pathtonewfile)
#
#   Generate the cmake script files that references the binaries of packages pubblished by the current framework.
#
function(generate_Framework_Binary_References)
set(dir ${CMAKE_SOURCE_DIR}/src/_packages)
list_Subdirectories(ALL_PACKAGES ${dir})
foreach(package IN LISTS ALL_PACKAGES)# generating binaries reference cmake files for each native package
	generate_Framework_Binary_Reference_For_Package(${package} TRUE)
endforeach()
#dealing also with external packages (no documentation only binary references)
set(dir ${CMAKE_SOURCE_DIR}/src/_external)
list_Subdirectories(ALL_PACKAGES ${dir})
foreach(package IN LISTS ALL_PACKAGES)
	generate_Framework_Binary_Reference_For_Package(${package} FALSE)
endforeach()
endfunction(generate_Framework_Binary_References)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Package_Page_Binaries_In_Framework| replace:: ``generate_Package_Page_Binaries_In_Framework``
#  .. _generate_Package_Page_Binaries_In_Framework:
#
#  generate_Package_Page_Binaries_In_Framework
#  -------------------------------------------
#
#   .. command:: generate_Package_Page_Binaries_In_Framework(package)
#
#   Create the markdown page that references available binary archives for a given native package, in the context of current framework project.
#
#     :package: the name of the native package.
#
function(generate_Package_Page_Binaries_In_Framework package)
set(PACKAGE_NAME ${package})
configure_file(${WORKSPACE_DIR}/cmake/patterns/static_sites/binaries.md.in ${CMAKE_SOURCE_DIR}/src/_packages/${package}/pages/binaries.md @ONLY)
endfunction(generate_Package_Page_Binaries_In_Framework)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_External_Page_Binaries_In_Framework| replace:: ``generate_External_Page_Binaries_In_Framework``
#  .. _generate_External_Page_Binaries_In_Framework:
#
#  generate_External_Page_Binaries_In_Framework
#  --------------------------------------------
#
#   .. command:: generate_External_Page_Binaries_In_Framework(package)
#
#   Create the markdown page that references available binary archives for a given external package, in the context of current framework project.
#
#     :package: the name of the external package.
#
function(generate_External_Page_Binaries_In_Framework package)
set(PACKAGE_NAME ${package})
# 2 alternatives: the external package has been put "by hand" into the framework OR
# the external package doc has been generated from a wrapper
if(EXISTS ${CMAKE_SOURCE_DIR}/src/_external/${package}/pages/introduction.md
AND EXISTS ${CMAKE_SOURCE_DIR}/src/_external/${package}/index.html)
	#first alternative, the package has been generated from a wrapper (these pages are caracteristic of such a generation)
	#simply add a page explaining the available binaries, like for native packages
	if(EXISTS ${CMAKE_SOURCE_DIR}/src/_external/${package}/index.md)
		#there is a automatically generated file that still lies in the folder => need to remove it
		file(REMOVE ${CMAKE_SOURCE_DIR}/src/_external/${package}/index.md)
	endif()
	configure_file(${WORKSPACE_DIR}/cmake/patterns/static_sites/binaries_wrapper.md.in ${CMAKE_SOURCE_DIR}/src/_external/${package}/pages/binaries.md @ONLY)
else()
	#second almternative, binaries have been put into the folder by hand
	#need to generate a simple index page that directly contains description of binaries
	set(PATH_TO_PAGE ${CMAKE_SOURCE_DIR}/src/_external/${package}/index.md)
	include_External_Reference_File(PATH_TO_REFERENCE_FILE ${package})
	if(NOT PATH_TO_REFERENCE_FILE)
		message("[PID] WARNING : reference file to package ${package} does not exists !")
		return()
	endif()
	if(EXISTS ${PATH_TO_PAGE}) #remove the file to be sure
		file(REMOVE ${PATH_TO_PAGE})
	endif()

	set(EXTERNAL_PACKAGE_NAME ${package})

	fill_String_From_List(DESCRIPTION_STRING ${package}_DESCRIPTION " ")
	set(EXTERNAL_PACKAGE_DESCRIPTION ${DESCRIPTION_STRING})

	fill_String_From_List(EXTERNAL_PACKAGE_AUTHORS ${package}_ORIGINAL_PROJECT_AUTHORS " ")
	fill_String_From_List(EXTERNAL_PACKAGE_LICENSE ${package}_ORIGINAL_PROJECT_LICENSES " ")

	# managing categories
	if(NOT ${package}_CATEGORIES)
		set(EXTERNAL_PACKAGE_CATEGORIES)
	else()
		list(LENGTH ${package}_CATEGORIES SIZE)
		if(SIZE EQUAL 1)
			set(EXTERNAL_PACKAGE_CATEGORIES ${${package}_CATEGORIES})
		else()
			set(EXTERNAL_PACKAGE_CATEGORIES "[")
			set(idx 0)
			foreach(cat IN LISTS ${package}_CATEGORIES)
				set(EXTERNAL_PACKAGE_CATEGORIES "${EXTERNAL_PACKAGE_CATEGORIES}${cat}")
				math(EXPR idx "${idx}+1")
				if(NOT idx EQUAL SIZE)
					set(EXTERNAL_PACKAGE_CATEGORIES "${EXTERNAL_PACKAGE_CATEGORIES},")
				endif()
			endforeach()
			set(EXTERNAL_PACKAGE_CATEGORIES "${EXTERNAL_PACKAGE_CATEGORIES}]")
		endif()
	endif()
	# managing binaries
	set(binary_dir ${CMAKE_SOURCE_DIR}/src/_external/${package}/binaries)
	list_Version_Subdirectories(ALL_VERSIONS ${binary_dir})
	set(PRINTED_VERSIONS)
	foreach(ref_version IN LISTS ALL_VERSIONS) #for each available version, all os for which there is a reference
		set(${ref_version}_PRINTED_PLATFORM)
		# binaries may be referenced with subdirectories (basic case)
		list_Platform_Subdirectories(ALL_PLATFORMS ${binary_dir}/${ref_version})
		foreach(ref_platform IN LISTS ALL_PLATFORMS)#for each platform of this version
			# now referencing the binaries
			list_Regular_Files(ALL_BINARIES ${binary_dir}/${ref_version}/${ref_platform})
			if(ALL_BINARIES AND EXISTS ${binary_dir}/${ref_version}/${ref_platform}/${package}-${ref_version}-${ref_platform}.tar.gz) # check to avoid problem if the binaries have been badly published
				list(APPEND PRINTED_VERSIONS ${ref_version})
				list(APPEND ${ref_version}_PRINTED_PLATFORM ${ref_platform})
			endif()
		endforeach()

		# binaries may also be referenced with symlinks (case when different platform can share the same binary package, typical with header only libraries)
		list_Platform_Symlinks(ALL_PLATFORMS ${binary_dir}/${ref_version})
		foreach(ref_platform IN LISTS ALL_PLATFORMS)#for each platform of this version
			# now referencing the binaries
			list_Regular_Files(ALL_BINARIES ${binary_dir}/${ref_version}/${ref_platform})
			if(ALL_BINARIES) #do not check for binary archive name since it may differ from standard regarding platform (king of generic platform name may be used)
				list(APPEND PRINTED_VERSIONS ${ref_version})
				list(APPEND ${ref_version}_PRINTED_PLATFORM ${ref_platform})
			endif()
		endforeach()
	endforeach()

	if(PRINTED_VERSIONS)
		list(REMOVE_DUPLICATES PRINTED_VERSIONS)
		list(SORT PRINTED_VERSIONS)
		foreach(version IN LISTS PRINTED_VERSIONS)
			set(EXTERNAL_PACKAGE_BINARIES "${EXTERNAL_PACKAGE_BINARIES}\n### ${version}\n\n")
			list(SORT ${version}_PRINTED_PLATFORM)
			foreach(platform IN LISTS ${version}_PRINTED_PLATFORM)
				set(EXTERNAL_PACKAGE_BINARIES "${EXTERNAL_PACKAGE_BINARIES} + ${platform}\n")
			endforeach()
		endforeach()
		set(EXTERNAL_PACKAGE_BINARIES "${EXTERNAL_PACKAGE_BINARIES}\n")
	else()
		set(EXTERNAL_PACKAGE_BINARIES "There is no binary provided for this package !")
	endif()
	#generate another index file
	configure_file(${WORKSPACE_DIR}/cmake/patterns/frameworks/external_index.md.in ${PATH_TO_PAGE} @ONLY)
endif()
endfunction(generate_External_Page_Binaries_In_Framework)

#.rst:
#
# .. ifmode:: internal
#
#  .. |generate_Framework_Binary_Reference_For_Package| replace:: ``generate_Framework_Binary_Reference_For_Package``
#  .. _generate_Framework_Binary_Reference_For_Package:
#
#  generate_Framework_Binary_Reference_For_Package
#  -----------------------------------------------
#
#   .. command:: generate_Framework_Binary_Reference_For_Package(package native)
#
#   Create the markdown pages that references available binary archives for a given package (native or external), in the context of current framework project.
#
#     :package: the name of the package.
#
#     :native: if TRUE it is a native package, otherwise it is an external package.
#
function(generate_Framework_Binary_Reference_For_Package package native)
if(native)
	generate_Package_Page_Binaries_In_Framework(${package}) # create markdown page listing available binaries
	set(dir ${CMAKE_SOURCE_DIR}/src/_packages/${package}/binaries)
else() # external packages have different deployment
	generate_External_Page_Binaries_In_Framework(${package})
	set(dir ${CMAKE_SOURCE_DIR}/src/_external/${package}/binaries)
endif()

set(${package}_FRAMEWORK_REFERENCES)
set(file ${dir}/binary_references.cmake)
file(WRITE ${file} "# Contains references to binaries that are available for ${package} \n")
#this may overwrite binary references hard coded in the reference file, or simply add new ones

##################################################################
### all available versions of the package for which there is a ###
### reference to a downloadable binary for any platform ##########
##################################################################
list_Version_Subdirectories(ALL_VERSIONS ${dir})

foreach(ref_version IN LISTS ALL_VERSIONS) #for each available version, all os for which there is a reference

	list_Platform_Subdirectories(ALL_PLATFORMS ${dir}/${ref_version})
	foreach(ref_platform IN LISTS ALL_PLATFORMS)#for each platform of this version
		# now referencing the binaries
		list_Regular_Files(ALL_BINARIES ${dir}/${ref_version}/${ref_platform})

		if(ALL_BINARIES) # check to avoid problem is the binaries have been badly released
			extract_Info_From_Platform(RES_ARCH RES_BITS RES_OS RES_ABI RES_INSTANCE RES_PLATFORM_BASE ${ref_platform})

			# the version is registered only if there are binaries inside (sanity check)
			if(native AND EXISTS ${dir}/${ref_version}/${ref_platform}/${package}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz)
				set(${package}_FRAMEWORK_REFERENCES ${${package}_FRAMEWORK_REFERENCES} ${ref_version})
				set(${package}_FRAMEWORK_REFERENCE_${ref_version} ${${package}_FRAMEWORK_REFERENCE_${ref_version}} ${ref_platform})
				set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL ${${PROJECT_NAME}_SITE}/packages/${package}/binaries/${ref_version}/${ref_platform}/${package}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz)# release version must exist for native packages

				if(EXISTS ${dir}/${ref_version}/${ref_platform}/${package}-${ref_version}-dbg-${RES_PLATFORM_BASE}.tar.gz)# debug version may no exist for native packages
					set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG ${${PROJECT_NAME}_SITE}/packages/${package}/binaries/${ref_version}/${ref_platform}/${package}-${ref_version}-dbg-${RES_PLATFORM_BASE}.tar.gz)
				endif()
			elseif(NOT native AND EXISTS ${dir}/${ref_version}/${ref_platform}/${package}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz) #at least a release version is required for external packages

				set(${package}_FRAMEWORK_REFERENCES ${${package}_FRAMEWORK_REFERENCES} ${ref_version})
				set(${package}_FRAMEWORK_REFERENCE_${ref_version} ${${package}_FRAMEWORK_REFERENCE_${ref_version}} ${ref_platform})
				set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL ${${PROJECT_NAME}_SITE}/external/${package}/binaries/${ref_version}/${ref_platform}/${package}-${ref_version}-${RES_PLATFORM_BASE}.tar.gz)
				set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_FOLDER ${package}-${ref_version}-${RES_PLATFORM_BASE})
				if(EXISTS ${dir}/${ref_version}/${ref_platform}/${package}-${ref_version}-dbg-${RES_PLATFORM_BASE}.tar.gz)
					set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG ${${PROJECT_NAME}_SITE}/external/${package}/binaries/${ref_version}/${ref_platform}/${package}-${ref_version}-dbg-${RES_PLATFORM_BASE}.tar.gz)
					set(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_FOLDER_DEBUG ${package}-${ref_version}-dbg-${RES_PLATFORM_BASE})
				endif()
			endif()
		endif()
	endforeach()
endforeach()

if(${package}_FRAMEWORK_REFERENCES)#there are registered references
	list(REMOVE_DUPLICATES ${package}_FRAMEWORK_REFERENCES)
	file(APPEND ${file} "set(${package}_REFERENCES ${${package}_FRAMEWORK_REFERENCES} CACHE INTERNAL \"\")\n") # the version is registered
	foreach(ref_version IN LISTS ${package}_FRAMEWORK_REFERENCES)
		list(REMOVE_DUPLICATES ${package}_FRAMEWORK_REFERENCE_${ref_version}) #there is at least one platform referenced so no need to test for nullity
		file(APPEND ${file} "set(${package}_REFERENCE_${ref_version} ${${package}_FRAMEWORK_REFERENCE_${ref_version}} CACHE INTERNAL \"\")\n")

		foreach(ref_platform IN LISTS ${package}_FRAMEWORK_REFERENCE_${ref_version})
			#release binary referencing
			file(APPEND ${file} "set(${package}_REFERENCE_${ref_version}_${ref_platform}_URL ${${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL} CACHE INTERNAL \"\")\n")#reference on the release binary
			if(NOT native)
				file(APPEND ${file} "set(${package}_REFERENCE_${ref_version}_${ref_platform}_FOLDER ${${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_FOLDER} CACHE INTERNAL \"\")\n")# name of the folder contained in the archive
			endif()

			#debug binary referencing
			if(${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG) #always true for open source native packages, may be true for external packages, never true for close source native packages
				file(APPEND ${file} "set(${package}_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG ${${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_URL_DEBUG} CACHE INTERNAL \"\")\n")#reference on the debug binary
				if(NOT native)
					file(APPEND ${file} "set(${package}_REFERENCE_${ref_version}_${ref_platform}_FOLDER_DEBUG ${${package}_FRAMEWORK_REFERENCE_${ref_version}_${ref_platform}_FOLDER_DEBUG} CACHE INTERNAL \"\")\n")#name of the folder contained in the archive
				endif()
			endif()
		endforeach()
	endforeach()
endif()
endfunction(generate_Framework_Binary_Reference_For_Package)

#.rst:
#
# .. ifmode:: internal
#
#  .. |build_Framework| replace:: ``build_Framework``
#  .. build_Framework:
#
#  build_Framework
#  ---------------
#
#   .. command:: build_Framework()
#
#  Finalize the configuration of the current framework project build process.
#
macro(build_Framework)

####################################################
############ CONFIGURING the BUILD #################
####################################################

# configuring all that can be configured from framework description
generate_Framework_Readme_File() # generating and putting into source directory the readme file used by gitlab
generate_Framework_License_File() # generating and putting into source directory the file containing license info about the package
generate_Framework_Data() # generating the data files for jekyll (result in the build tree)
generate_Framework_Binary_References() # generating in the project the cmake script files that allow to find references on packages of the framework
update_Environment_CI_Config_File() #update CI file with version coming from framework

# build steps
# 1) create or clean the "generated" folder in build tree.
# 2) create or clean the "to_generate" folder in build tree. When created all files are copied from "static" folder of framework pattern. When cleaned only user specific code is removed
# 3) copy all framework specific content from src (hand written or generated by packages) INTO the "to_generate" folder.
# 4) call jekyll on the "to_generate" folder with "generated" as output => the output site is in the "generated" folder of the build tree.

#########################################################################################################################
######### writing the global reference file for the package with all global info contained in the CMakeFile.txt #########
#########################################################################################################################
if(${PROJECT_NAME}_ADDRESS)
	generate_Framework_Reference_File(${CMAKE_BINARY_DIR}/share/ReferFramework${PROJECT_NAME}.cmake)
	#copy the reference file of the package into the "references" folder of the workspace
	get_Path_To_All_Deployment_Unit_References_Publishing_Contribution_Spaces(ALL_PUBLISHING_CS ${PROJECT_NAME})
	add_custom_target(referencing
		COMMAND ${CMAKE_COMMAND}
						-DWORKSPACE_DIR=${WORKSPACE_DIR}
						-DTARGET_FRAMEWORK=${PROJECT_NAME}
						-DCMAKE_BINARY_DIR=${CMAKE_BINARY_DIR}
						-DALL_PUBLISHING_CS=\"${ALL_PUBLISHING_CS}\"
						-P ${WORKSPACE_DIR}/cmake/commands/Referencing_PID_Deployment_Unit.cmake
		WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
	)
endif()
endmacro(build_Framework)


#########################################################################################
############################ CI for external packages wrappers ##########################
#########################################################################################

#.rst:
#
# .. ifmode:: internal
#
#  .. |verify_Framework_CI_Content| replace:: ``verify_Framework_CI_Content``
#  .. _verify_Framework_CI_Content:
#
#  verify_Framework_CI_Content
#  ---------------------------
#
#   .. command:: verify_Framework_CI_Content()
#
#    Verify that framework CI scripts exist in wrapper repository and perform corrective action otherwise.
#
function(verify_Framework_CI_Content)

if(NOT EXISTS ${CMAKE_SOURCE_DIR}/share/ci)#the ci folder is missing
	file(COPY ${WORKSPACE_DIR}/cmake/patterns/frameworks/framework/share/ci DESTINATION ${CMAKE_SOURCE_DIR}/share)
	message("[PID] INFO : creating the ci folder in framework ${PROJECT_NAME} repository")
elseif(NOT IS_DIRECTORY ${CMAKE_SOURCE_DIR}/share/ci)#the ci folder is missing
	file(REMOVE ${CMAKE_SOURCE_DIR}/share/ci)
	message("[PID] WARNING : removed file ${CMAKE_SOURCE_DIR}/share/ci in framework ${PROJECT_NAME}")
	file(COPY ${WORKSPACE_DIR}/cmake/patterns/frameworks/framework/share/ci DESTINATION ${CMAKE_SOURCE_DIR}/share)
	message("[PID] INFO : creating the ci folder in framework ${PROJECT_NAME} repository")
else() #updating these files by silently replacing the ci folder
	file(REMOVE_RECURSE ${CMAKE_SOURCE_DIR}/share/ci)
	file(COPY ${WORKSPACE_DIR}/cmake/patterns/frameworks/framework/share/ci DESTINATION ${CMAKE_SOURCE_DIR}/share)
endif()
endfunction(verify_Framework_CI_Content)
